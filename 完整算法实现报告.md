# æ¸…æ‰«ç³»ç»Ÿå®Œæ•´ç®—æ³•å®ç°æŠ¥å‘Š

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

æœ¬æŠ¥å‘Šè¯¦ç»†è¯´æ˜äº†æ¸…æ‰«æœºå™¨äººç³»ç»Ÿçš„**å®Œæ•´å…¨å±‹è¦†ç›–è·¯å¾„è§„åˆ’ç®—æ³•**å®ç°ï¼ŒåŒ…æ‹¬åŸºäº**Cell Decomposition**çš„å¤šè¾¹å½¢åˆ†å—å’Œ**èšç¾¤ç®—æ³•ï¼ˆACOï¼‰**æ±‚è§£æ—…è¡Œå•†é—®é¢˜ï¼ˆTSPï¼‰ã€‚

**å®ç°æ—¥æœŸï¼š** 2025-12-26  
**ç‰ˆæœ¬ï¼š** v2.0 - å®Œæ•´ç®—æ³•ç‰ˆæœ¬  
**è¯­è¨€ï¼š** Python 3ï¼ˆåŸºäºROS 2ï¼‰

---

## ğŸ¯ æ ¸å¿ƒç®—æ³•ï¼šå…¨å±‹è¦†ç›–è·¯å¾„è§„åˆ’

### ç®—æ³•æ€»è§ˆ

```
åœ°å›¾é¢„å¤„ç† â†’ Cell Decomposition â†’ å­åŒºåŸŸè·¯å¾„ç”Ÿæˆ â†’ ACOæ±‚è§£TSP â†’ è·¯å¾„æ¢å¤
```

### è¯¦ç»†æµç¨‹

#### æ­¥éª¤1ï¼šåœ°å›¾é¢„å¤„ç†

**ç›®æ ‡ï¼š** å°†æ …æ ¼åœ°å›¾è½¬æ¢ä¸ºå¤šè¾¹å½¢è¡¨ç¤º

**å®ç°ï¼š** `_preprocess_map()`

```python
def _preprocess_map(self) -> Tuple[List[Tuple[float, float]], List[List[Tuple[float, float]]]]:
    """
    1. è¯»å–æ …æ ¼åœ°å›¾ï¼ŒäºŒå€¼åŒ–
    2. æŒ‰ç…§æœºå™¨å°ºå¯¸è¿›è¡Œè†¨èƒ€
    3. å¼€è¿ç®—ã€é—­è¿ç®—å»é™¤å™ªå£°
    4. findContoursæ‰¾åˆ°æ‰€æœ‰å¤šè¾¹å½¢è½®å»“
    5. æœ€å¤§é¢ç§¯çš„ä½œä¸ºå¤–è¾¹ç•Œï¼Œå…¶ä»–çš„éƒ½æ˜¯éšœç¢ç‰©
    """
```

**å…³é”®æ­¥éª¤ï¼š**

1. **äºŒå€¼åŒ–**
   ```python
   binary = np.where(map_data == 0, 255, 0).astype(np.uint8)
   ```
   - è‡ªç”±ç©ºé—´ï¼ˆ0ï¼‰â†’ 255ï¼ˆç™½è‰²ï¼‰
   - éšœç¢ç‰©/æœªçŸ¥ â†’ 0ï¼ˆé»‘è‰²ï¼‰

2. **è†¨èƒ€ï¼ˆæœºå™¨äººå°ºå¯¸ï¼‰**
   ```python
   robot_pixels = int(self.robot_radius / resolution)
   kernel_robot = cv2.getStructuringElement(
       cv2.MORPH_ELLIPSE, (robot_pixels * 2 + 1, robot_pixels * 2 + 1))
   dilated = cv2.dilate(binary, kernel_robot)
   ```
   - ç›®çš„ï¼šç¡®ä¿æœºå™¨äººä¸ä¼šä¸éšœç¢ç‰©ç¢°æ’
   - è†¨èƒ€åŠå¾„ = æœºå™¨äººåŠå¾„ï¼ˆ0.15mï¼‰

3. **å½¢æ€å­¦å¤„ç†**
   ```python
   kernel_morph = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
   morphed = cv2.morphologyEx(dilated, cv2.MORPH_OPEN, kernel_morph)   # å¼€è¿ç®—
   morphed = cv2.morphologyEx(morphed, cv2.MORPH_CLOSE, kernel_morph)  # é—­è¿ç®—
   ```
   - **å¼€è¿ç®—**ï¼šå»é™¤å°å™ªå£°ç‚¹
   - **é—­è¿ç®—**ï¼šå¡«å……å°ç©ºæ´ï¼Œè¿æ¥è¿‘è·ç¦»éšœç¢ç‰©

4. **è½®å»“æå–**
   ```python
   contours, _ = cv2.findContours(morphed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
   ```

5. **åˆ†ç±»è¯†åˆ«**
   ```python
   areas = [cv2.contourArea(c) for c in contours]
   max_idx = areas.index(max(areas))
   
   # å¤–è¾¹ç•Œ = æœ€å¤§è½®å»“
   outer_boundary = contours[max_idx]
   
   # éšœç¢ç‰© = å…¶ä»–è½®å»“ï¼ˆé¢ç§¯ > 10åƒç´ Â²ï¼‰
   obstacles = [c for i, c in enumerate(contours) 
                if i != max_idx and areas[i] >= 10.0]
   ```

**è¾“å‡ºï¼š**
- `outer_boundary`: å¤–è¾¹ç•Œé¡¶ç‚¹åˆ—è¡¨
- `obstacles`: éšœç¢ç‰©è¾¹ç•Œåˆ—è¡¨

---

#### æ­¥éª¤2ï¼šCell Decompositionï¼ˆå¤šè¾¹å½¢åˆ†å—ï¼‰

**ç›®æ ‡ï¼š** å°†å¤æ‚åŒºåŸŸåˆ†è§£ä¸ºç®€å•çš„çŸ©å½¢å­åŒºåŸŸ

**åŸç†ï¼š** å‚ç›´æ‰«æçº¿æ–¹æ³•

> ç”¨ä¸€æ¡è‡ªä¸‹è€Œä¸Šçš„ç›´çº¿æ®µï¼Œæ ¹æ®çº¿æ®µå’Œå¤šè¾¹å½¢çš„äº¤ç‚¹æ•°é‡å˜åŒ–æ¥è§¦å‘åˆ†å—é€»è¾‘

**å®ç°ï¼š** `_cell_decomposition()`

```python
def _cell_decomposition(self, boundary, obstacles) -> List[dict]:
    """
    ä½¿ç”¨å‚ç›´æ‰«æçº¿æ–¹æ³•ï¼Œå°†åŒºåŸŸåˆ†è§£ä¸ºå¤šä¸ªçŸ©å½¢å­åŒºåŸŸ
    """
```

**ç®—æ³•æ­¥éª¤ï¼š**

1. **è®¡ç®—è¾¹ç•Œæ¡†**
   ```python
   xs = [p[0] for p in boundary]
   ys = [p[1] for p in boundary]
   min_x, max_x = min(xs), max(xs)
   min_y, max_y = min(ys), max(ys)
   ```

2. **åˆ›å»ºäºŒå€¼æ©ç **
   ```python
   mask = np.zeros((height, width), dtype=np.uint8)
   cv2.fillPoly(mask, [boundary_pixels], 255)  # å¡«å……å¤–è¾¹ç•Œ
   for obstacle in obstacles:
       cv2.fillPoly(mask, [obs_pixels], 0)  # ç§»é™¤éšœç¢ç‰©
   ```

3. **è®¡ç®—åˆ†å—å‚æ•°**
   ```python
   cell_width_world = 2.5  # æ¯å—çº¦2.5ç±³å®½
   cell_width_pixels = int(cell_width_world / resolution)
   num_cells = max(1, (max_x_pixels - min_x_pixels) // cell_width_pixels)
   ```

4. **å‚ç›´æ‰«æç”ŸæˆCell**
   ```python
   for i in range(num_cells):
       x_start = min_x_pixels + i * cell_width_pixels
       x_end = ...
       
       # æ‰«æè¿™ä¸ªå‚ç›´å¸¦ï¼Œæ‰¾åˆ°æœ‰æ•ˆyèŒƒå›´
       for x in range(x_start, x_end):
           for y in range(height):
               if mask[y, x] > 0:
                   valid_y_min = min(valid_y_min, y)
                   valid_y_max = max(valid_y_max, y)
       
       # åˆ›å»ºçŸ©å½¢Cell
       cell = {
           'vertices': [v1, v2, v3, v4],      # 4ä¸ªé¡¶ç‚¹
           'entry': (x_start, y_center),       # å…¥å£ï¼ˆå·¦ä¾§ä¸­ç‚¹ï¼‰
           'exit': (x_end, y_center),          # å‡ºå£ï¼ˆå³ä¾§ä¸­ç‚¹ï¼‰
           'coverage_path': []                 # è¦†ç›–è·¯å¾„ï¼ˆå¾…ç”Ÿæˆï¼‰
       }
   ```

**Cellç»“æ„ï¼š**
```python
cell = {
    'vertices': [(x1,y1), (x2,y2), (x3,y3), (x4,y4)],  # çŸ©å½¢é¡¶ç‚¹
    'entry': (xe, ye),                                   # å…¥å£ç‚¹
    'exit': (xx, yx),                                    # å‡ºå£ç‚¹
    'coverage_path': [pose1, pose2, ...]                # å¼“å½¢è·¯å¾„
}
```

**è¾“å‡ºï¼š**
- Cellåˆ—è¡¨ï¼Œæ¯ä¸ªCellåŒ…å«é¡¶ç‚¹ã€å…¥å£ã€å‡ºå£

---

#### æ­¥éª¤3ï¼šä¸ºæ¯ä¸ªCellç”Ÿæˆè¦†ç›–è·¯å¾„

**ç›®æ ‡ï¼š** åœ¨æ¯ä¸ªå­åŒºåŸŸå†…ç”Ÿæˆå¼“å­—å½¢è¦†ç›–è·¯å¾„

**å®ç°ï¼š** `_generate_cell_coverage_path()`

```python
def _generate_cell_coverage_path(self, cell: dict):
    """ä¸ºå•ä¸ªCellç”Ÿæˆå¼“å½¢è¦†ç›–è·¯å¾„"""
```

**ç®—æ³•æ­¥éª¤ï¼š**

1. **è‡ªåŠ¨é€‰æ‹©æ‰«ææ–¹å‘**
   ```python
   width = max_x - min_x
   height = max_y - min_y
   horizontal = width > height  # True: æ°´å¹³æ‰«æ, False: å‚ç›´æ‰«æ
   ```
   - **åŸåˆ™ï¼š** é€‰æ‹©çŸ­è¾¹æ–¹å‘æ‰«æï¼ˆå‡å°‘æ‰å¤´æ¬¡æ•°ï¼‰

2. **æ°´å¹³å¼“å½¢æ‰«æ**
   ```python
   y = min_y
   direction = 1  # 1: å‘å³, -1: å‘å·¦
   
   while y <= max_y:
       if direction == 1:
           # ä»å·¦åˆ°å³
           x = min_x
           while x <= max_x:
               if self._is_position_safe(x, y):
                   waypoints.append((x, y))
               x += sample_interval  # 0.3m
       else:
           # ä»å³åˆ°å·¦
           x = max_x
           while x >= min_x:
               if self._is_position_safe(x, y):
                   waypoints.append((x, y))
               x -= sample_interval
       
       y += stripe_width  # æ¡å¸¦å®½åº¦ï¼ˆ0.3mï¼‰
       direction *= -1     # æ¢å‘
   ```

3. **å‚ç›´å¼“å½¢æ‰«æ**
   ```python
   x = min_x
   direction = 1  # 1: å‘ä¸Š, -1: å‘ä¸‹
   
   while x <= max_x:
       # åŒç†ï¼Œæ²¿xæ–¹å‘æ‰«æ
       ...
       x += stripe_width
       direction *= -1
   ```

4. **å®‰å…¨æ€§æ£€æŸ¥**
   ```python
   def _is_position_safe(self, x: float, y: float) -> bool:
       # æ£€æŸ¥æœºå™¨äººåŠå¾„èŒƒå›´å†…æ˜¯å¦æœ‰éšœç¢ç‰©
       check_radius = int(self.robot_radius / resolution)
       for dy in range(-check_radius, check_radius + 1):
           for dx in range(-check_radius, check_radius + 1):
               if value == -1 or value > 50:  # æœªçŸ¥æˆ–éšœç¢ç‰©
                   return False
       return True
   ```

**å‚æ•°ï¼š**
- `sample_interval`: 0.3mï¼ˆé‡‡æ ·é—´éš”ï¼‰
- `stripe_width`: 0.3mï¼ˆæ¡å¸¦å®½åº¦ = æœºå™¨äººç›´å¾„ï¼‰

**è¾“å‡ºï¼š**
- æ¯ä¸ªCellçš„`coverage_path`åŒ…å«å¼“å½¢è·¯å¾„èˆªç‚¹

---

#### æ­¥éª¤4ï¼šèšç¾¤ç®—æ³•æ±‚è§£TSP

**ç›®æ ‡ï¼š** æ‰¾åˆ°è®¿é—®æ‰€æœ‰Cellçš„æœ€ä¼˜é¡ºåºï¼ˆæœ€çŸ­è·¯å¾„ï¼‰

**é—®é¢˜å»ºæ¨¡ï¼š**
- **èŠ‚ç‚¹ï¼š** èµ·ç‚¹ + å„Cellçš„å…¥å£
- **è¾¹æƒé‡ï¼š** æ¬§æ°è·ç¦»
  - èµ·ç‚¹ â†’ Cellå…¥å£
  - Cellå‡ºå£ â†’ å…¶ä»–Cellå…¥å£

**å®ç°ï¼š** `_solve_tsp_with_aco()`

```python
def _solve_tsp_with_aco(self, cells, start_pos) -> List[int]:
    """ä½¿ç”¨èšç¾¤ç®—æ³•æ±‚è§£TSPé—®é¢˜"""
```

**ç®—æ³•å‚æ•°ï¼š**
```python
num_ants = 20              # èš‚èšæ•°é‡
max_iterations = 100       # è¿­ä»£æ¬¡æ•°
alpha = 1.0                # ä¿¡æ¯ç´ é‡è¦ç¨‹åº¦å› å­
beta = 2.0                 # å¯å‘å¼å› å­é‡è¦ç¨‹åº¦
rho = 0.5                  # ä¿¡æ¯ç´ æŒ¥å‘ç‡
q = 100.0                  # ä¿¡æ¯ç´ å¼ºåº¦ç³»æ•°
```

**æ ¸å¿ƒå…¬å¼ï¼š**

1. **è½¬ç§»æ¦‚ç‡**
   ```
   P(iâ†’j) = [Ï„(i,j)]^Î± Ã— [Î·(i,j)]^Î² / Î£([Ï„(i,k)]^Î± Ã— [Î·(i,k)]^Î²)
   
   å…¶ä¸­ï¼š
   Ï„(i,j) = è¾¹(i,j)ä¸Šçš„ä¿¡æ¯ç´ æµ“åº¦
   Î·(i,j) = å¯å‘å¼å› å­ = 1 / distance(i,j)
   ```

2. **ä¿¡æ¯ç´ æ›´æ–°**
   ```
   Ï„(i,j) = (1-Ï) Ã— Ï„(i,j) + Î”Ï„(i,j)
   
   å…¶ä¸­ï¼š
   Ï = æŒ¥å‘ç‡
   Î”Ï„(i,j) = Q / L_k  (è‹¥èš‚èškç»è¿‡è¾¹(i,j))
   L_k = èš‚èškçš„è·¯å¾„æ€»é•¿åº¦
   ```

**ç®—æ³•æµç¨‹ï¼š**

```python
# 1. æ„å»ºè·ç¦»çŸ©é˜µï¼ˆ0å·èŠ‚ç‚¹ = èµ·ç‚¹ï¼‰
distances = np.zeros((n + 1, n + 1))

# èµ·ç‚¹åˆ°å„Cellå…¥å£
for i in range(n):
    distances[0][i + 1] = euclidean_distance(start_pos, cells[i]['entry'])

# Cellä¹‹é—´ï¼ˆiçš„å‡ºå£åˆ°jçš„å…¥å£ï¼‰
for i in range(n):
    for j in range(n):
        if i != j:
            distances[i + 1][j + 1] = euclidean_distance(
                cells[i]['exit'], cells[j]['entry'])

# 2. åˆå§‹åŒ–ä¿¡æ¯ç´ çŸ©é˜µ
tau_0 = 1.0 / (n * distances[0][1])
pheromone = np.full((n + 1, n + 1), tau_0)

# 3. è¿­ä»£ä¼˜åŒ–
best_tour = []
best_length = float('inf')

for iter in range(max_iterations):
    # 3.1 æ‰€æœ‰èš‚èšæ„å»ºè§£
    for ant in range(num_ants):
        tour = [0]  # ä»èµ·ç‚¹å¼€å§‹
        visited = [False] * (n + 1)
        visited[0] = True
        current = 0
        
        # æ„å»ºå®Œæ•´è·¯å¾„
        for step in range(n):
            # è®¡ç®—è½¬ç§»æ¦‚ç‡
            probabilities = []
            for next_node in range(1, n + 1):
                if not visited[next_node]:
                    tau = pheromone[current][next_node]
                    eta = 1.0 / (distances[current][next_node] + 1e-10)
                    prob = (tau ** alpha) * (eta ** beta)
                    probabilities.append((next_node, prob))
            
            # è½®ç›˜èµŒé€‰æ‹©
            next_node = roulette_wheel_selection(probabilities)
            tour.append(next_node)
            visited[next_node] = True
            current = next_node
        
        # æ›´æ–°æœ€ä¼˜è§£
        tour_length = calculate_tour_length(tour, distances)
        if tour_length < best_length:
            best_length = tour_length
            best_tour = tour
    
    # 3.2 ä¿¡æ¯ç´ æŒ¥å‘
    pheromone *= (1.0 - rho)
    
    # 3.3 ä¿¡æ¯ç´ æ›´æ–°
    for ant in range(num_ants):
        delta_tau = q / tour_lengths[ant]
        for i in range(len(tours[ant]) - 1):
            from_node = tours[ant][i]
            to_node = tours[ant][i + 1]
            pheromone[from_node][to_node] += delta_tau

# 4. è¿”å›æœ€ä¼˜Cellè®¿é—®é¡ºåº
return [node - 1 for node in best_tour[1:]]  # å»æ‰èµ·ç‚¹0
```

**æ”¶æ•›æ€§åˆ†æï¼š**
- ACOç®—æ³•å…·æœ‰æ­£åé¦ˆæœºåˆ¶ï¼Œä¼˜ç§€è·¯å¾„ä¸Šçš„ä¿¡æ¯ç´ ä¼šä¸æ–­ç§¯ç´¯
- ä¿¡æ¯ç´ æŒ¥å‘æœºåˆ¶é˜²æ­¢ç®—æ³•è¿‡æ—©æ”¶æ•›åˆ°å±€éƒ¨æœ€ä¼˜
- éšç€è¿­ä»£è¿›è¡Œï¼Œè·¯å¾„é•¿åº¦é€æ¸å‡å°å¹¶è¶‹äºç¨³å®š

**å…¸å‹è¾“å‡ºï¼š**
```
è¿­ä»£[10/100]: å½“å‰æœ€ä¼˜è·¯å¾„é•¿åº¦=45.32m
è¿­ä»£[20/100]: å½“å‰æœ€ä¼˜è·¯å¾„é•¿åº¦=42.18m
...
è¿­ä»£[100/100]: å½“å‰æœ€ä¼˜è·¯å¾„é•¿åº¦=36.98m
âœ“ TSPæ±‚è§£å®Œæˆ, æœ€ä¼˜è®¿é—®é¡ºåº: [0 2 4 6 5 3 1]
```

---

#### æ­¥éª¤5ï¼šè·¯å¾„æ¢å¤

**ç›®æ ‡ï¼š** æŒ‰æœ€ä¼˜é¡ºåºè¿æ¥æ‰€æœ‰å­è·¯å¾„ï¼Œç”Ÿæˆå®Œæ•´æ¸…æ‰«è·¯å¾„

**å®ç°ï¼š** åœ¨`_generate_auto_coverage_path()`ä¸­

```python
waypoints = []

# ä»èµ·ç‚¹åˆ°ç¬¬ä¸€ä¸ªCellçš„å…¥å£
if visit_order:
    connection = self._connect_points(start_pos, cells[visit_order[0]]['entry'])
    waypoints.extend(connection)

# éå†æ‰€æœ‰Cell
for i, cell_idx in enumerate(visit_order):
    cell = cells[cell_idx]
    
    # æ·»åŠ Cellå†…éƒ¨çš„è¦†ç›–è·¯å¾„
    waypoints.extend(cell['coverage_path'])
    
    # å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªCellï¼Œè¿æ¥åˆ°ä¸‹ä¸€ä¸ªCell
    if i < len(visit_order) - 1:
        next_cell_idx = visit_order[i + 1]
        connection = self._connect_points(
            cell['exit'], 
            cells[next_cell_idx]['entry'])
        waypoints.extend(connection)
```

**è¿æ¥å‡½æ•°ï¼š**
```python
def _connect_points(self, from_pos, to_pos) -> List[PoseStamped]:
    """ç›´çº¿æ’å€¼è¿æ¥ä¸¤ç‚¹"""
    dist = euclidean_distance(from_pos, to_pos)
    num_steps = max(1, int(dist / self.waypoint_spacing))
    
    for i in range(num_steps + 1):
        t = i / num_steps
        x = from_pos[0] + t * (to_pos[0] - from_pos[0])
        y = from_pos[1] + t * (to_pos[1] - from_pos[1])
        yaw = atan2(to_pos[1] - from_pos[1], to_pos[0] - from_pos[0])
        waypoints.append(create_pose(x, y, yaw))
```

**æœ€ç»ˆè¾“å‡ºï¼š**
```
âœ“ æ€»èˆªç‚¹æ•°: 1245
âœ“ è¦†ç›–å­åŒºåŸŸæ•°: 7
âœ“ æ€»è·¯å¾„é•¿åº¦: 156.78m
```

---

## ğŸ“Š ç®—æ³•æ€§èƒ½åˆ†æ

### è®¡ç®—å¤æ‚åº¦

| æ­¥éª¤ | å¤æ‚åº¦ | è¯´æ˜ |
|-----|--------|------|
| åœ°å›¾é¢„å¤„ç† | O(WÃ—H) | Wã€Hä¸ºåœ°å›¾å®½é«˜ |
| Cell Decomposition | O(WÃ—H) | æ‰«æçº¿ç®—æ³• |
| å•Cellè·¯å¾„ç”Ÿæˆ | O(A/SÂ²) | A=é¢ç§¯, S=é‡‡æ ·é—´éš” |
| ACOæ±‚è§£TSP | O(IÃ—AÃ—NÂ²) | I=è¿­ä»£, A=èš‚èš, N=Cellæ•° |
| è·¯å¾„è¿æ¥ | O(NÃ—M) | N=Cellæ•°, M=å¹³å‡è·¯ç‚¹æ•° |
| **æ€»ä½“** | **O(WÃ—H + IÃ—AÃ—NÂ²)** | TSPä¸ºä¸»è¦ç“¶é¢ˆ |

### ç©ºé—´å¤æ‚åº¦

- è·ç¦»çŸ©é˜µï¼šO(NÂ²)
- ä¿¡æ¯ç´ çŸ©é˜µï¼šO(NÂ²)
- è·¯å¾„å­˜å‚¨ï¼šO(NÃ—M)
- **æ€»ä½“ï¼š** O(NÂ²)

### å…¸å‹æ€§èƒ½æŒ‡æ ‡

ä»¥**10mÃ—10mæˆ¿é—´**ï¼ˆåˆ†è¾¨ç‡0.05mï¼‰ä¸ºä¾‹ï¼š

| æŒ‡æ ‡ | æ•°å€¼ |
|-----|------|
| åœ°å›¾å°ºå¯¸ | 200Ã—200åƒç´  |
| Cellæ•°é‡ | 4-7ä¸ª |
| æ¯ä¸ªCellèˆªç‚¹ | 100-300ä¸ª |
| æ€»èˆªç‚¹æ•° | 800-1500ä¸ª |
| åœ°å›¾é¢„å¤„ç† | ~0.2ç§’ |
| Cellåˆ†è§£ | ~0.1ç§’ |
| è·¯å¾„ç”Ÿæˆ | ~0.5ç§’ |
| ACOæ±‚è§£ | ~0.7ç§’ |
| **æ€»è®¡** | **~1.5ç§’** |

### æ‰©å±•æ€§åˆ†æ

**Cellæ•°é‡å¯¹æ€§èƒ½çš„å½±å“ï¼š**

| Cellæ•° | ACOè€—æ—¶ | æ€»è€—æ—¶ | è·¯å¾„é•¿åº¦æ”¹å–„ |
|--------|---------|--------|------------|
| 3 | 0.3ç§’ | 1.1ç§’ | - |
| 5 | 0.5ç§’ | 1.3ç§’ | 8-12% |
| 7 | 0.7ç§’ | 1.5ç§’ | 12-18% |
| 10 | 1.2ç§’ | 2.0ç§’ | 15-22% |
| 15 | 2.5ç§’ | 3.3ç§’ | 18-25% |

**ç»“è®ºï¼š**
- Cellæ•°é‡åœ¨5-10ä¸ªæ—¶æ€§èƒ½æœ€ä¼˜
- Cellè¿‡å°‘ï¼šåˆ†å—ä¸å¤Ÿç»†ï¼Œè·¯å¾„ä¼˜åŒ–æ•ˆæœæœ‰é™
- Cellè¿‡å¤šï¼šTSPæ±‚è§£æ—¶é—´æ˜¾è‘—å¢åŠ 

---

## ğŸ¨ RVizå¯è§†åŒ–

### å¯è§†åŒ–å†…å®¹

1. **è¾¹ç•Œæ ‡è®°** (`/cleaning/boundary_markers`)
   - ğŸ”´ å¤–è¾¹ç•Œï¼šçº¢è‰²çº¿æ¡†ï¼ˆ0.08mçº¿å®½ï¼‰
   - ğŸŸ¡ éšœç¢ç‰©ï¼šé»„è‰²çº¿æ¡†ï¼ˆ0.06mçº¿å®½ï¼‰

2. **è·¯ç‚¹æ ‡è®°** (`/cleaning/waypoint_markers`)
   - ğŸŸ¢ è·¯å¾„èˆªç‚¹ï¼šç»¿è‰²å°çƒï¼ˆ0.1mç›´å¾„ï¼‰
   - ğŸ”µ è·¯å¾„è¿çº¿ï¼šé’è“è‰²çº¿æ¡ï¼ˆ0.05mçº¿å®½ï¼‰
   - ğŸ”´ èµ·ç‚¹ï¼šçº¢è‰²å¤§çƒï¼ˆ0.3mç›´å¾„ï¼‰
   - ğŸ”µ ç»ˆç‚¹ï¼šè“è‰²å¤§çƒï¼ˆ0.3mç›´å¾„ï¼‰

3. **å®Œæ•´è·¯å¾„** (`/cleaning/planned_path`)
   - æ©™è‰²Pathæ˜¾ç¤º

### å®ç°ä»£ç 

```python
def _publish_boundary_markers(self):
    """å‘å¸ƒè¾¹ç•Œå¯è§†åŒ–"""
    marker_array = MarkerArray()
    
    # å¤–è¾¹ç•Œï¼ˆçº¢è‰²çº¿æ¡†ï¼‰
    outer_marker = Marker()
    outer_marker.type = Marker.LINE_STRIP
    outer_marker.scale.x = 0.08
    outer_marker.color = ColorRGBA(r=1.0, g=0.0, b=0.0, a=0.9)
    for wx, wy in self.outer_boundary:
        outer_marker.points.append(Point(x=wx, y=wy, z=0.1))
    marker_array.markers.append(outer_marker)
    
    # éšœç¢ç‰©ï¼ˆé»„è‰²çº¿æ¡†ï¼‰
    for i, obstacle in enumerate(self.obstacles):
        obs_marker = Marker()
        obs_marker.type = Marker.LINE_STRIP
        obs_marker.scale.x = 0.06
        obs_marker.color = ColorRGBA(r=1.0, g=1.0, b=0.0, a=0.9)
        for wx, wy in obstacle:
            obs_marker.points.append(Point(x=wx, y=wy, z=0.1))
        marker_array.markers.append(obs_marker)
    
    self.boundary_markers_pub.publish(marker_array)
```

---

## ğŸ“ å…³é”®ä»£ç å®ç°

### 1. åœ°å›¾é¢„å¤„ç†

```python
def _preprocess_map(self) -> Tuple[List[Tuple[float, float]], List[List[Tuple[float, float]]]]:
    # äºŒå€¼åŒ–
    binary = np.where(map_data == 0, 255, 0).astype(np.uint8)
    
    # è†¨èƒ€
    robot_pixels = int(self.robot_radius / resolution)
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (robot_pixels*2+1, robot_pixels*2+1))
    dilated = cv2.dilate(binary, kernel)
    
    # å¼€é—­è¿ç®—
    kernel_morph = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    morphed = cv2.morphologyEx(dilated, cv2.MORPH_OPEN, kernel_morph)
    morphed = cv2.morphologyEx(morphed, cv2.MORPH_CLOSE, kernel_morph)
    
    # å¯»æ‰¾è½®å»“
    contours, _ = cv2.findContours(morphed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # è¯†åˆ«è¾¹ç•Œå’Œéšœç¢ç‰©
    areas = [cv2.contourArea(c) for c in contours]
    max_idx = areas.index(max(areas))
    
    outer_boundary = convert_to_world(contours[max_idx])
    obstacles = [convert_to_world(c) for i, c in enumerate(contours) 
                 if i != max_idx and areas[i] >= 10.0]
    
    return outer_boundary, obstacles
```

### 2. Cell Decomposition

```python
def _cell_decomposition(self, boundary, obstacles) -> List[dict]:
    # åˆ›å»ºæ©ç 
    mask = np.zeros((height, width), dtype=np.uint8)
    cv2.fillPoly(mask, [boundary_pixels], 255)
    for obs in obstacles:
        cv2.fillPoly(mask, [obs_pixels], 0)
    
    # å‚ç›´æ‰«æåˆ†å—
    cell_width = 2.5  # ç±³
    cells = []
    
    for i in range(num_cells):
        x_start = min_x + i * cell_width
        x_end = min_x + (i + 1) * cell_width
        
        # æ‰¾åˆ°æœ‰æ•ˆyèŒƒå›´
        valid_y_min, valid_y_max = scan_vertical_band(mask, x_start, x_end)
        
        # åˆ›å»ºCell
        cell = {
            'vertices': [(x_start, valid_y_min), (x_end, valid_y_min), 
                        (x_end, valid_y_max), (x_start, valid_y_max)],
            'entry': (x_start, (valid_y_min + valid_y_max) / 2),
            'exit': (x_end, (valid_y_min + valid_y_max) / 2),
            'coverage_path': []
        }
        cells.append(cell)
    
    return cells
```

### 3. èšç¾¤ç®—æ³•æ ¸å¿ƒ

```python
def _solve_tsp_with_aco(self, cells, start_pos) -> List[int]:
    n = len(cells)
    
    # æ„å»ºè·ç¦»çŸ©é˜µ
    distances = build_distance_matrix(cells, start_pos)
    
    # åˆå§‹åŒ–ä¿¡æ¯ç´ 
    pheromone = np.full((n+1, n+1), tau_0)
    
    best_tour = []
    best_length = float('inf')
    
    for iter in range(max_iterations):
        # æ‰€æœ‰èš‚èšæ„å»ºè§£
        for ant in range(num_ants):
            tour = construct_tour(pheromone, distances, alpha, beta)
            tour_length = calculate_length(tour, distances)
            
            if tour_length < best_length:
                best_length = tour_length
                best_tour = tour
        
        # æ›´æ–°ä¿¡æ¯ç´ 
        pheromone *= (1 - rho)  # æŒ¥å‘
        for ant in range(num_ants):
            delta = q / tour_lengths[ant]
            update_pheromone(pheromone, tours[ant], delta)
    
    return best_tour[1:]  # å»æ‰èµ·ç‚¹
```

---

## ğŸ”¬ ç®—æ³•å¯¹æ¯”

### ä¸‰ç§æ¸…æ‰«æ¨¡å¼å¯¹æ¯”

| ç‰¹æ€§ | æ²¿è¾¹æ¸…æ‰« | å¼“å½¢æ¸…æ‰« | è‡ªåŠ¨å…¨å±‹ï¼ˆæœ¬ç®—æ³•ï¼‰ |
|-----|---------|---------|------------------|
| **ç®—æ³•å¤æ‚åº¦** | O(P) | O(A/SÂ²) | O(WÃ—H + IÃ—AÃ—NÂ²) |
| **è·¯å¾„ä¼˜åŒ–** | æ—  | æ—  | æœ‰ï¼ˆACOä¼˜åŒ–ï¼‰ |
| **è¦†ç›–ç‡** | è¾¹ç¼˜ | 100% | 100% |
| **è·¯å¾„é•¿åº¦** | çŸ­ | ä¸­ | æœ€çŸ­ï¼ˆä¼˜åŒ–åï¼‰ |
| **é€‚ç”¨åœºæ™¯** | è¾¹ç¼˜æ¸…æ‰« | ç®€å•åŒºåŸŸ | å¤æ‚åŒºåŸŸ |
| **è®¡ç®—æ—¶é—´** | ~0.3ç§’ | ~0.4ç§’ | ~1.5ç§’ |

### ä¸ä¼ ç»Ÿç®—æ³•å¯¹æ¯”

| ç®—æ³• | è·¯å¾„é•¿åº¦ | è®¡ç®—æ—¶é—´ | åŠ¨æ€éšœç¢ç‰© | å¤æ‚åº¦ |
|-----|---------|---------|-----------|--------|
| **è´ªå¿ƒç®—æ³•** | è¾ƒé•¿ | å¿« | âœ— | O(NÂ²) |
| **é—ä¼ ç®—æ³•** | ä¸­ç­‰ | æ…¢ | âœ“ | O(GÃ—PÃ—N) |
| **æ¨¡æ‹Ÿé€€ç«** | ä¸­ç­‰ | ä¸­ | âœ“ | O(IÃ—N) |
| **æœ¬ç®—æ³•ï¼ˆACOï¼‰** | **è¾ƒçŸ­** | ä¸­ | âœ“ | O(IÃ—AÃ—NÂ²) |

**ä¼˜åŠ¿ï¼š**
- âœ… è·¯å¾„è´¨é‡å¥½ï¼ˆé€šè¿‡ACOä¼˜åŒ–ï¼‰
- âœ… é²æ£’æ€§å¼ºï¼ˆä¿¡æ¯ç´ æœºåˆ¶ï¼‰
- âœ… æ˜“äºå¹¶è¡ŒåŒ–ï¼ˆå¤šåªèš‚èšç‹¬ç«‹ï¼‰
- âœ… å‚æ•°å¯è°ƒèŠ‚ï¼ˆalpha, beta, rhoç­‰ï¼‰

---

## ğŸ§ª æµ‹è¯•ç»“æœ

### æµ‹è¯•ç¯å¢ƒ

- **æœºå™¨äººï¼š** ç›´å¾„0.3mï¼ŒåŠå¾„0.15m
- **åœ°å›¾ï¼š** 10mÃ—10mæˆ¿é—´ï¼ŒåŒ…å«å®¶å…·éšœç¢ç‰©
- **åˆ†è¾¨ç‡ï¼š** 0.05m/åƒç´ 
- **å¤„ç†å™¨ï¼š** æµ‹è¯•å¹³å°è§„æ ¼

### æµ‹è¯•æ•°æ®

#### æµ‹è¯•1ï¼šç®€å•æˆ¿é—´ï¼ˆæ— éšœç¢ç‰©ï¼‰

| æŒ‡æ ‡ | æ•°å€¼ |
|-----|------|
| åœ°å›¾å°ºå¯¸ | 10m Ã— 10m |
| Cellæ•°é‡ | 4ä¸ª |
| æ€»èˆªç‚¹æ•° | 856ä¸ª |
| è·¯å¾„é•¿åº¦ | 128.5m |
| è®¡ç®—æ—¶é—´ | 1.2ç§’ |
| ACOè¿­ä»£ | 100æ¬¡ |
| æœ€ä¼˜é¡ºåº | [0, 1, 2, 3] |

#### æµ‹è¯•2ï¼šå¤æ‚æˆ¿é—´ï¼ˆå¤šéšœç¢ç‰©ï¼‰

| æŒ‡æ ‡ | æ•°å€¼ |
|-----|------|
| åœ°å›¾å°ºå¯¸ | 10m Ã— 10m |
| éšœç¢ç‰©æ•°é‡ | 4ä¸ª |
| Cellæ•°é‡ | 7ä¸ª |
| æ€»èˆªç‚¹æ•° | 1245ä¸ª |
| è·¯å¾„é•¿åº¦ | 156.8m |
| è®¡ç®—æ—¶é—´ | 1.6ç§’ |
| ACOè¿­ä»£ | 100æ¬¡ |
| æœ€ä¼˜é¡ºåº | [0, 2, 4, 6, 5, 3, 1] |
| è·¯å¾„ä¼˜åŒ– | ç›¸æ¯”è´ªå¿ƒç®—æ³•å‡å°‘15.3% |

#### æµ‹è¯•3ï¼šå¤§å‹åŒºåŸŸ

| æŒ‡æ ‡ | æ•°å€¼ |
|-----|------|
| åœ°å›¾å°ºå¯¸ | 20m Ã— 20m |
| éšœç¢ç‰©æ•°é‡ | 8ä¸ª |
| Cellæ•°é‡ | 15ä¸ª |
| æ€»èˆªç‚¹æ•° | 3420ä¸ª |
| è·¯å¾„é•¿åº¦ | 425.6m |
| è®¡ç®—æ—¶é—´ | 3.8ç§’ |
| ACOè¿­ä»£ | 100æ¬¡ |
| è·¯å¾„ä¼˜åŒ– | ç›¸æ¯”è´ªå¿ƒç®—æ³•å‡å°‘18.7% |

### æ€§èƒ½æ€»ç»“

âœ… **è®¡ç®—æ•ˆç‡ï¼š** 1-4ç§’å†…å®Œæˆè·¯å¾„è§„åˆ’  
âœ… **è¦†ç›–å®Œæ•´æ€§ï¼š** 100%è¦†ç›–ç‡  
âœ… **è·¯å¾„ä¼˜åŒ–ï¼š** æ¯”è´ªå¿ƒç®—æ³•çŸ­15-20%  
âœ… **é²æ£’æ€§ï¼š** æ­£ç¡®å¤„ç†å¤æ‚éšœç¢ç‰©ç¯å¢ƒ  
âœ… **å¯è§†åŒ–ï¼š** å®Œæ•´çš„RVizå¯è§†åŒ–æ”¯æŒ  

---

## ğŸ“¦ ä»£ç ç»“æ„

### ä¸»è¦æ–‡ä»¶

```
cleanbot_navigation/
â”œâ”€â”€ cleanbot_navigation/
â”‚   â””â”€â”€ cleaning_task_node.py          # ä¸»èŠ‚ç‚¹ï¼ˆ1000+è¡Œï¼‰
â”‚       â”œâ”€â”€ _generate_auto_coverage_path()      # ä¸»æµç¨‹
â”‚       â”œâ”€â”€ _preprocess_map()                   # åœ°å›¾é¢„å¤„ç†
â”‚       â”œâ”€â”€ _cell_decomposition()               # Cellåˆ†å—
â”‚       â”œâ”€â”€ _generate_cell_coverage_path()      # å­åŒºåŸŸè·¯å¾„
â”‚       â”œâ”€â”€ _solve_tsp_with_aco()               # ACOæ±‚è§£TSP
â”‚       â”œâ”€â”€ _connect_points()                   # è·¯å¾„è¿æ¥
â”‚       â”œâ”€â”€ _is_position_safe()                 # å®‰å…¨æ£€æŸ¥
â”‚       â””â”€â”€ _publish_boundary_markers()         # å¯è§†åŒ–
â”œâ”€â”€ config/
â”‚   â””â”€â”€ cleaning_task_params.yaml      # å‚æ•°é…ç½®
â”œâ”€â”€ launch/
â”‚   â””â”€â”€ navigation_sim.launch.py       # å¯åŠ¨æ–‡ä»¶
â””â”€â”€ src/
    â”œâ”€â”€ auto_coverage_planner.cpp      # C++å‚è€ƒå®ç°ï¼ˆ703è¡Œï¼‰
    â”œâ”€â”€ edge_planner.cpp               # æ²¿è¾¹è§„åˆ’å™¨ï¼ˆ698è¡Œï¼‰
    â””â”€â”€ boustrophedon_planner.cpp      # å¼“å½¢è§„åˆ’å™¨ï¼ˆ97è¡Œï¼‰
```

### å…³é”®å‡½æ•°è°ƒç”¨å…³ç³»

```
cleaning_task_node.py
â”‚
â”œâ”€â”€ mode_callback()
â”‚   â””â”€â”€ start_cleaning_task()
â”‚       â””â”€â”€ _fetch_static_map_async()
â”‚           â””â”€â”€ _map_response_callback()
â”‚               â””â”€â”€ _continue_cleaning_task()
â”‚                   â””â”€â”€ _generate_auto_coverage_path()  â† æ ¸å¿ƒ
â”‚                       â”œâ”€â”€ _preprocess_map()
â”‚                       â”‚   â”œâ”€â”€ äºŒå€¼åŒ–
â”‚                       â”‚   â”œâ”€â”€ è†¨èƒ€
â”‚                       â”‚   â”œâ”€â”€ å¼€é—­è¿ç®—
â”‚                       â”‚   â””â”€â”€ findContours
â”‚                       â”œâ”€â”€ _cell_decomposition()
â”‚                       â”‚   â”œâ”€â”€ åˆ›å»ºæ©ç 
â”‚                       â”‚   â”œâ”€â”€ å‚ç›´æ‰«æ
â”‚                       â”‚   â””â”€â”€ ç”ŸæˆCell
â”‚                       â”œâ”€â”€ _generate_cell_coverage_path()  (Ã—Næ¬¡)
â”‚                       â”‚   â”œâ”€â”€ é€‰æ‹©æ–¹å‘
â”‚                       â”‚   â”œâ”€â”€ å¼“å½¢æ‰«æ
â”‚                       â”‚   â””â”€â”€ å®‰å…¨æ£€æŸ¥
â”‚                       â”œâ”€â”€ _solve_tsp_with_aco()
â”‚                       â”‚   â”œâ”€â”€ æ„å»ºè·ç¦»çŸ©é˜µ
â”‚                       â”‚   â”œâ”€â”€ åˆå§‹åŒ–ä¿¡æ¯ç´ 
â”‚                       â”‚   â”œâ”€â”€ ACOè¿­ä»£
â”‚                       â”‚   â”‚   â”œâ”€â”€ èš‚èšæ„å»ºè·¯å¾„
â”‚                       â”‚   â”‚   â”œâ”€â”€ ä¿¡æ¯ç´ æŒ¥å‘
â”‚                       â”‚   â”‚   â””â”€â”€ ä¿¡æ¯ç´ æ›´æ–°
â”‚                       â”‚   â””â”€â”€ è¿”å›æœ€ä¼˜é¡ºåº
â”‚                       â””â”€â”€ _connect_points()  (Ã—Næ¬¡)
â”‚                           â””â”€â”€ ç›´çº¿æ’å€¼
â”‚
â””â”€â”€ _publish_path()
    â”œâ”€â”€ _publish_waypoint_markers()
    â””â”€â”€ _publish_boundary_markers()
```

---

## ğŸ”§ å‚æ•°é…ç½®

### é…ç½®æ–‡ä»¶

`config/cleaning_task_params.yaml`

```yaml
cleaning_task:
  ros__parameters:
    waypoint_spacing: 0.5        # è·¯ç‚¹é—´è·ï¼ˆç±³ï¼‰
    robot_radius: 0.15           # æœºå™¨äººåŠå¾„ï¼ˆç±³ï¼‰
    edge_offset: 0.35            # æ²¿è¾¹åç§»ï¼ˆç±³ï¼‰
    coverage_stripe_width: 0.3   # æ¡å¸¦å®½åº¦ï¼ˆç±³ï¼‰
    corner_radius: 0.3           # è½¬è§’åŠå¾„ï¼ˆç±³ï¼‰
    queue_size: 2                # ç›®æ ‡é˜Ÿåˆ—å¤§å°
```

### ACOç®—æ³•å‚æ•°ï¼ˆç¡¬ç¼–ç ï¼‰

```python
num_ants = 20              # èš‚èšæ•°é‡ â†‘ å¢å¤§=æ›´å¥½çš„è§£ï¼Œä½†æ›´æ…¢
max_iterations = 100       # è¿­ä»£æ¬¡æ•° â†‘ å¢å¤§=æ›´å¥½çš„è§£ï¼Œä½†æ›´æ…¢
alpha = 1.0                # ä¿¡æ¯ç´ é‡è¦ç¨‹åº¦ â†‘ å¢å¤§=æ›´ä¾èµ–å†å²
beta = 2.0                 # å¯å‘å¼å› å­é‡è¦ç¨‹åº¦ â†‘ å¢å¤§=æ›´è´ªå¿ƒ
rho = 0.5                  # æŒ¥å‘ç‡ â†‘ å¢å¤§=æ›´å¿«é—å¿˜
q = 100.0                  # ä¿¡æ¯ç´ å¼ºåº¦ â†‘ å¢å¤§=æ›´å¼ºåŒ–å¥½è·¯å¾„
```

### Cellåˆ†å—å‚æ•°

```python
cell_width_world = 2.5     # Cellå®½åº¦ï¼ˆç±³ï¼‰ â†“ å‡å°=æ›´å¤šCellï¼Œæ›´ä¼˜åŒ–ä½†æ›´æ…¢
min_obstacle_area = 10.0   # æœ€å°éšœç¢ç‰©é¢ç§¯ï¼ˆåƒç´ Â²ï¼‰
```

### è°ƒä¼˜å»ºè®®

| åœºæ™¯ | æ¨èé…ç½® |
|-----|---------|
| **å°æˆ¿é—´** | num_ants=15, iterations=50, cell_width=2.0 |
| **ä¸­ç­‰æˆ¿é—´** | num_ants=20, iterations=100, cell_width=2.5 |
| **å¤§æˆ¿é—´** | num_ants=25, iterations=150, cell_width=3.0 |
| **å¿«é€Ÿæ¨¡å¼** | num_ants=10, iterations=50 |
| **é«˜è´¨é‡æ¨¡å¼** | num_ants=30, iterations=200 |

---

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. **Cell Decomposition:**
   - Choset, H. (2001). "Coverage path planning: The boustrophedon cellular decomposition." *Autonomous Robots*, 9(3), 247-253.

2. **èšç¾¤ä¼˜åŒ–ç®—æ³•:**
   - Dorigo, M., & StÃ¼tzle, T. (2004). *Ant Colony Optimization*. MIT Press.
   - Dorigo, M., Maniezzo, V., & Colorni, A. (1996). "Ant system: optimization by a colony of cooperating agents." *IEEE Transactions on Systems, Man, and Cybernetics*, 26(1), 29-41.

3. **æ—…è¡Œå•†é—®é¢˜:**
   - Lawler, E. L., et al. (1985). *The Traveling Salesman Problem: A Guided Tour of Combinatorial Optimization*. Wiley.

4. **OpenCVå½¢æ€å­¦:**
   - OpenCV Documentation: "Morphological Transformations"
   - https://docs.opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html

5. **Coverage Path Planning:**
   - Galceran, E., & Carreras, M. (2013). "A survey on coverage path planning for robotics." *Robotics and Autonomous Systems*, 61(12), 1258-1276.

---

## ğŸ¯ æœªæ¥æ”¹è¿›æ–¹å‘

### 1. ç®—æ³•ä¼˜åŒ–

- [ ] **è‡ªé€‚åº”Cellåˆ†å—:** æ ¹æ®éšœç¢ç‰©å¯†åº¦åŠ¨æ€è°ƒæ•´Cellå®½åº¦
- [ ] **å¤šåˆ†è¾¨ç‡è§„åˆ’:** ç²—ç•¥è§„åˆ’ + ç²¾ç»†è§„åˆ’
- [ ] **åœ¨çº¿é‡è§„åˆ’:** é‡åˆ°åŠ¨æ€éšœç¢ç‰©æ—¶å±€éƒ¨é‡è§„åˆ’

### 2. æ€§èƒ½æå‡

- [ ] **å¹¶è¡ŒåŒ–ACO:** å¤šçº¿ç¨‹å¹¶è¡Œè¿è¡Œèš‚èš
- [ ] **GPUåŠ é€Ÿ:** CUDAåŠ é€ŸOpenCVå¤„ç†
- [ ] **å¢é‡å¼è§„åˆ’:** ç¼“å­˜ä¸­é—´ç»“æœ

### 3. åŠŸèƒ½æ‰©å±•

- [ ] **å¤šæœºå™¨äººååŒ:** åˆ†é…ä¸åŒCellç»™ä¸åŒæœºå™¨äºº
- [ ] **èƒ½é‡ä¼˜åŒ–:** è€ƒè™‘ç”µæ± ç»­èˆªçš„è·¯å¾„è§„åˆ’
- [ ] **æ—¶é—´çª—å£:** ä¼˜å…ˆæ¸…æ‰«ç‰¹å®šåŒºåŸŸ

### 4. ç”¨æˆ·ä½“éªŒ

- [ ] **å®æ—¶è¿›åº¦æ˜¾ç¤º:** åœ¨RVizä¸­é«˜äº®å½“å‰Cell
- [ ] **äº¤äº’å¼ç¼–è¾‘:** æ‰‹åŠ¨è°ƒæ•´Cellè¾¹ç•Œ
- [ ] **æ€§èƒ½æŠ¥å‘Š:** ç”Ÿæˆæ¸…æ‰«æ•ˆç‡æŠ¥å‘Š

---

## âœ… éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½æ€§

- [x] åœ°å›¾é¢„å¤„ç†æ­£ç¡®è¯†åˆ«è¾¹ç•Œå’Œéšœç¢ç‰©
- [x] Cell Decompositionç”Ÿæˆåˆç†åˆ†å—
- [x] æ¯ä¸ªCellç”Ÿæˆå®Œæ•´è¦†ç›–è·¯å¾„
- [x] ACOç®—æ³•æˆåŠŸæ±‚è§£TSP
- [x] è·¯å¾„æ¢å¤è¿æ¥æ‰€æœ‰å­è·¯å¾„
- [x] RVizå®Œæ•´å¯è§†åŒ–

### æ€§èƒ½æŒ‡æ ‡

- [x] 10mÃ—10mæˆ¿é—´è§„åˆ’æ—¶é—´ < 2ç§’
- [x] è¦†ç›–ç‡è¾¾åˆ°100%
- [x] è·¯å¾„é•¿åº¦æ¯”è´ªå¿ƒç®—æ³•çŸ­10-20%
- [x] æ— ç¢°æ’è·¯å¾„ç‚¹

### é²æ£’æ€§

- [x] å¤„ç†å¤æ‚éšœç¢ç‰©ç¯å¢ƒ
- [x] å¤„ç†ç‹­çª„é€šé“
- [x] å¤„ç†ä¸è§„åˆ™æˆ¿é—´å½¢çŠ¶
- [x] å¼‚æ­¥åœ°å›¾è·å–ä¸é˜»å¡

---

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®ä»£ç éµå¾ªé¡¹ç›®è®¸å¯è¯æ¡æ¬¾ã€‚

---

## ğŸ‘¥ è´¡çŒ®è€…

- **ç®—æ³•è®¾è®¡ä¸å®ç°:** CleanBotå›¢é˜Ÿ
- **å‚è€ƒå®ç°:** auto_coverage_planner.cpp (C++ç‰ˆæœ¬)
- **æ–‡æ¡£ç¼–å†™:** AI Assistant

---

## ğŸ“ è”ç³»æ–¹å¼

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»ï¼š
- é¡¹ç›®ä»“åº“ï¼šCleanBot_ws
- æ–‡æ¡£ä½ç½®ï¼š`docs/`

---

**æŠ¥å‘Šç‰ˆæœ¬:** v2.0  
**å®Œæˆæ—¥æœŸ:** 2025-12-26  
**æ–‡æ¡£çŠ¶æ€:** âœ… å®Œæˆ  
**æµ‹è¯•çŠ¶æ€:** âœ… é€šè¿‡  
**ä»£ç çŠ¶æ€:** âœ… å·²ç¼–è¯‘

