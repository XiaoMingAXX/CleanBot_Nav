# 修复说明：目标队列管理和路径生成优化

## 📋 问题描述

### 问题1：所有目标点被同时发送导致相互抢占
**现象：**
```
[bt_navigator] Received goal preemption request
[bt_navigator] [ActionServer] Aborting handle.
✗ 目标点[2-10]失败，状态: 6 (ABORTED)
```

**原因：**
- `queue_size=2`，期望只保持2个活跃目标
- 但实际上一次性发送了所有11个目标点
- 原因是`_send_navigation_goal()`是异步的，回调还没执行时`active_goals`字典还是空的
- `_fill_goal_queue()`的条件`len(self.active_goals) < self.queue_size`一直为真
- 导致while循环一次性发送了所有航点

### 问题2：沿边路径不完整
**现象：**
```
✅ 路径生成完成: 11个航点
⚠ 跳过了4个不安全的路径点（有障碍物）
```

**问题：**
- 边界只有4个顶点（矩形）
- 4个边界点被判定为不安全，全部跳过
- 最后一个边界点到第一个边界点之间没有插值（不形成闭环）
- 插值间距太大（0.3m），路径点太少
- 安全检查过于严格，边界点本身可能在"不安全"区域

---

## ✅ 解决方案

### 修复1：目标点队列管理

**核心思路：** 在异步发送目标前就占位，防止重复发送

**修改文件：** `cleaning_task_node.py`

**修改内容：**

#### 1. `_send_navigation_goal()` - 发送前占位
```python
def _send_navigation_goal(self, waypoint: PoseStamped, waypoint_idx: int):
    # ... 前面的代码 ...
    
    # ✅ 先占位，防止_fill_goal_queue重复发送
    temp_key = f'temp_{waypoint_idx}'
    self.active_goals[temp_key] = (None, waypoint_idx)
    
    send_future = self.navigate_client.send_goal_async(goal_msg)
    send_future.add_done_callback(
        lambda future, idx=waypoint_idx, temp=temp_key: 
            self._goal_response_callback(future, idx, temp))
```

**说明：**
- 使用临时字符串键`temp_{waypoint_idx}`占位
- 让`len(self.active_goals)`立即增加
- 阻止`_fill_goal_queue()`继续发送
- 回调时再替换为真实的`id(goal_handle)`

#### 2. `_goal_response_callback()` - 回调时替换
```python
def _goal_response_callback(self, future, waypoint_idx: int, temp_key: str):
    goal_handle = future.result()
    
    # ✅ 移除临时键
    if temp_key in self.active_goals:
        del self.active_goals[temp_key]
    
    if not goal_handle.accepted:
        self.get_logger().error(f'  ✗ 目标点[{waypoint_idx + 1}]被拒绝')
        return
    
    # ✅ 使用真实的id(goal_handle)作为键
    self.active_goals[id(goal_handle)] = (goal_handle, waypoint_idx)
    
    # ... 后续代码 ...
```

**效果：**
- ✅ 严格控制队列大小为`queue_size=2`
- ✅ 避免目标点相互抢占
- ✅ 顺序执行清扫任务

---

### 修复2：沿边路径生成优化

**核心思路：** 生成完整闭环，增加路径密度，放宽安全检查

**修改内容：**

#### 1. 完整闭环遍历
```python
# ✅ 遍历所有边界点，形成闭环
for count in range(len(boundary)):
    idx = (closest_idx + count) % len(boundary)
    next_idx = (closest_idx + count + 1) % len(boundary)  # ← 确保闭环
    
    curr_x, curr_y = boundary[idx]
    next_x, next_y = boundary[next_idx]
```

**改进：**
- ✅ `next_idx`也使用取模，确保最后一个点连接到第一个点
- ✅ 形成完整闭环

#### 2. 增加路径密度
```python
# ✅ 边界点之间插值（固定0.2m间距，更密集）
if dist > 0.2:  # ← 从0.3m降低到0.2m
    num_steps = int(dist / 0.2)
    
    for j in range(1, num_steps):
        t = j / num_steps
        x = curr_x + t * dx
        y = curr_y + t * dy
        # ...
```

**改进：**
- ✅ 插值间距从0.3m降低到0.2m
- ✅ 路径更平滑，覆盖更完整

#### 3. 放宽安全检查
```python
def _is_position_safe(self, x: float, y: float) -> bool:
    # ...
    
    # ✅ 检查机器人半径范围内（稍微缩小检查半径，避免过于保守）
    check_radius = int(self.robot_radius / resolution * 0.8)  # ← 缩小到80%
    
    # ...
    
    # ✅ 提高阈值，只避开明显的障碍物
    if value == -1 or value > 80:  # ← 从50提高到80
        return False
```

**改进：**
- ✅ 检查半径缩小到原来的80%
- ✅ 障碍物阈值从50提高到80（只避开明显障碍物）
- ✅ 允许边界点更靠近墙壁

#### 4. 边界点处理
```python
# ✅ 添加当前边界点（放宽安全检查，只检查中心点）
waypoints.append(self._create_pose_simple(curr_x, curr_y, yaw))
added_count += 1

# 边界点之间插值
if dist > 0.2:
    # ... 插值代码 ...
    if self._is_position_safe(x, y):  # ← 只对插值点做安全检查
        waypoints.append(self._create_pose_simple(x, y, yaw))
        added_count += 1
    else:
        skipped_count += 1
```

**改进：**
- ✅ 边界点本身不做安全检查，直接添加
- ✅ 只对插值点做安全检查
- ✅ 确保完整覆盖边界

---

## 📊 预期效果对比

### 修复前
```
发送目标点 [1/11]: (0.01, -0.03)
发送目标点 [2/11]: (0.22, 0.19)
发送目标点 [3/11]: (0.43, 0.40)
...
发送目标点 [11/11]: (2.73, 2.73)

✗ 目标点[2]失败，状态: 6
✗ 目标点[3]失败，状态: 6
...
✗ 目标点[10]失败，状态: 6
✓ 完成目标点 [11/11]

问题：前10个目标都被抢占失败，只完成了最后一个
```

### 修复后
```
发送目标点 [1/50]: (0.01, -0.03)
发送目标点 [2/50]: (0.21, 0.17)
============================================================
✓ 完成目标点 [1/50]
进度: [█░░░░...] 2.0%
============================================================
发送目标点 [3/50]: (0.41, 0.35)
============================================================
✓ 完成目标点 [2/50]
进度: [██░░░...] 4.0%
============================================================
...

预期效果：
- ✅ 只保持2个活跃目标
- ✅ 完成一个补充一个
- ✅ 路径点增加到约50个（更完整）
- ✅ 沿边界完整绕一圈
```

---

## 🧪 测试步骤

### 1. 启动系统
```bash
cd ~/桌面/MOON/Electronic/CleanBot_ws
source install/setup.bash
ros2 launch cleanbot_navigation navigation_sim.launch.py
```

### 2. 启动RViz
```bash
rviz2 -d ~/桌面/MOON/Electronic/CleanBot_ws/src/cleanbot_navigation/rviz/cleanbot_nav_view.rviz
```

### 3. 设置初始位置
在RViz中使用"2D Pose Estimate"工具设置机器人初始位置

### 4. 发送沿边清扫命令
```bash
ros2 topic pub --once /cleaning/mode_cmd std_msgs/msg/UInt8 "{data: 1}"
```

### 5. 观察预期效果

**终端输出：**
```
✓ 生成了XX个沿边路径点  （← 应该比之前多）
📍 发布完整清扫路径: XX个航点
发送目标点 [1/XX]: (x, y)
发送目标点 [2/XX]: (x, y)
... (只发送2个)
============================================================
✓ 完成目标点 [1/XX]
进度: [█░░░...] X.X%
============================================================
发送目标点 [3/XX]: (x, y)  （← 补充一个）
...
```

**RViz显示：**
- ✅ 红色边界线框完整显示
- ✅ 绿色路点沿边界密集分布
- ✅ 青色路径连线形成闭环
- ✅ 机器人沿着边界完整移动一圈

**机器人行为：**
- ✅ 从起点移动到最近的边界点
- ✅ 沿着边界顺时针或逆时针完整绕一圈
- ✅ 回到起点附近
- ✅ 任务完成

---

## 🔍 关键代码变化

### 数据结构：活跃目标管理
```python
# 旧版（有问题）：
self.active_goals = {}  # {id(goal_handle): (goal_handle, waypoint_idx)}
# 问题：异步发送时字典还是空的

# 新版（修复）：
self.active_goals = {}  
# - 发送前：{'temp_0': (None, 0), 'temp_1': (None, 1)}  ← 临时占位
# - 回调后：{12345: (handle0, 0), 67890: (handle1, 1)}  ← 真实ID
```

### 路径生成：闭环逻辑
```python
# 旧版（不完整）：
if count < len(boundary) - 1:  # ← 最后一个点不插值
    # 插值代码
    
# 新版（完整闭环）：
for count in range(len(boundary)):  # ← 所有点都插值
    idx = (closest_idx + count) % len(boundary)
    next_idx = (closest_idx + count + 1) % len(boundary)  # ← 确保闭环
    # 插值代码
```

---

## 📝 配置参数

### 可调参数（`cleaning_task_params.yaml`）

```yaml
cleaning_task:
  ros__parameters:
    waypoint_spacing: 0.5        # 路点间距（米）- 用于Cell连接
    robot_radius: 0.15           # 机器人半径（米）
    edge_offset: 0.35            # 沿边偏移距离（米）
    queue_size: 2                # 目标点队列大小 ← 控制同时发送的目标数
```

### 硬编码参数（`cleaning_task_node.py`）

```python
# 沿边插值间距
sample_interval = 0.2  # 米（从0.3m降低到0.2m）

# 安全检查
check_radius = int(self.robot_radius / resolution * 0.8)  # 80%半径
obstacle_threshold = 80  # 障碍物阈值（从50提高到80）
```

---

## ⚠️ 注意事项

1. **队列大小调整**
   - `queue_size=2`适合大多数情况
   - 如果路径点很近，可以增加到3-4
   - 不建议超过5，可能导致路径跟踪问题

2. **安全检查调整**
   - 当前设置对沿边清扫较为宽松
   - 如果机器人碰撞墙壁，可以降低阈值
   - 如果路径点太少，可以进一步提高阈值

3. **插值密度**
   - 0.2m间距对大多数场景足够
   - 如果需要更精细的路径，可以降低到0.15m
   - 过密会导致路径点过多，影响性能

---

## ✅ 验证清单

- [ ] 只发送`queue_size`个目标点（默认2个）
- [ ] 完成一个目标后自动补充下一个
- [ ] 没有目标点被抢占（status != 6）
- [ ] 路径点数量明显增加（从11个增加到40-60个）
- [ ] 路径形成完整闭环（起点和终点接近）
- [ ] 机器人沿边界完整移动一圈
- [ ] RViz显示完整的红色边界框和绿色路径点
- [ ] 终端显示实时进度更新

---

**修复版本：** v2.1  
**修复日期：** 2025-12-26  
**状态：** ✅ 已编译，待测试









