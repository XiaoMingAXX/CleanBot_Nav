# 前端手动控制模块修改说明

## 修改概述

将原有的"速度控制"模块改造为"手动控制"模块，新增模式切换、里程反馈和里程控制功能。

## 主要修改内容

### 1. HTML界面修改 (`web/templates/index.html`)

#### 原"速度控制"卡片 → "手动控制"卡片

**新增功能**：
- **模式切换按钮**：遥控模式 / 里程模式
- **遥控模式面板**：虚拟摇杆（原有）
- **里程模式面板**：
  - 移动距离输入框（米）
  - 转向角度输入框（度）
  - 执行运动按钮

**反馈信息显示**：
- 控制模式：当前是遥控还是里程模式
- 累积路程：机器人累积移动的总距离
- 当前航向：机器人当前朝向（度数）
- 发布线速度：当前发送给控制器的线速度
- 发布角速度：当前发送给控制器的角速度

#### CSS样式新增
- 输入框样式和焦点效果
- 与整体主题一致的渐变和阴影

### 2. JavaScript功能修改 (`web/static/control.js`)

#### 新增变量
```javascript
let manualControlMode = 0;  // 0=遥控模式, 1=里程模式
const manualControlModeNames = ['遥控', '里程'];
let manualControlFeedback = {
    accumulated_distance: 0.0,
    current_yaw: 0.0,
    control_mode: 0,
    navigation_mode: 0
};
```

#### 新增函数

**`setManualControlMode(mode)`**
- 功能：切换手动控制模式
- 参数：mode (0=遥控, 1=里程)
- 行为：
  - 更新按钮状态
  - 切换显示面板（摇杆 or 输入框）
  - 里程模式下停止摇杆运动

**`sendOdometryCommand()`**
- 功能：发送里程控制命令
- 读取：距离和角度输入值
- 转换：角度→弧度
- 发送：`odometry_control` 类型的WebSocket消息

#### 修改函数

**`updateRobotState(state)`**
- 新增：处理 `state.manual_control` 反馈数据
- 更新：累积路程、当前航向、控制模式显示

**`sendVelocityCommand()`**
- 修改：在里程模式下禁用摇杆速度发送
- 条件：`manualControlMode === 1` 时不发送摇杆速度

**`window.onload`**
- 新增：初始化手动控制模式为遥控模式

### 3. WebSocket消息格式

#### 遥控模式 - 速度命令
```javascript
{
    type: 'cmd_vel',
    linear: 0.2,    // m/s
    angular: 0.5    // rad/s
}
```

#### 里程模式 - 里程命令
```javascript
{
    type: 'odometry_control',
    distance: 1.0,  // m (距离增量)
    yaw: 1.5708     // rad (角度增量，π/2 = 90度)
}
```

#### 状态反馈 - manual_control
```javascript
state.manual_control = {
    accumulated_distance: 0.0,  // 累积路程 (m)
    current_yaw: 0.0,           // 当前航向 (rad)
    control_mode: 0,            // 0=遥控, 1=里程
    navigation_mode: 0          // 0=手动, 1=建图, 2=导航
}
```

## 使用说明

### 遥控模式
1. 点击"遥控模式"按钮
2. 使用虚拟摇杆控制机器人移动
3. 实时显示发布的线速度和角速度

### 里程模式
1. 点击"里程模式"按钮
2. 输入移动距离（米）和转向角度（度）
3. 点击"执行运动"按钮
4. 机器人自动执行精确移动
5. 实时显示累积路程和当前航向

### 反馈信息
- **控制模式**：显示当前模式（遥控/里程）
- **累积路程**：显示机器人累积移动的总距离
- **当前航向**：显示机器人当前朝向（角度）
- **发布线速度/角速度**：显示实时发送给控制器的速度值

## 技术要点

### 1. 时间戳类型
manual_control_node发布的速度命令类型为`TwistStamped`，包含时间戳：
```python
cmd_msg = TwistStamped()
cmd_msg.header.stamp = self.get_clock().now().to_msg()
cmd_msg.header.frame_id = 'base_footprint'
cmd_msg.twist.linear.x = vx
cmd_msg.twist.angular.z = wz
```

### 2. 时间同步
- **仿真环境**：`use_sim_time: true`，使用仿真时间
- **实机环境**：`use_sim_time: false`，使用系统时间
- manual_control_node根据参数自动适配

### 3. 模式切换
- 里程模式下摇杆自动禁用
- 切换模式时自动停止机器人运动
- 导航模式下整个手动控制模块被禁用

### 4. 红外安全
- 前方红外触发：限制前进
- 左/右红外触发：限制转向
- 里程模式下红外触发自动修改目标值

## 文件清单

### 修改文件
- `web/templates/index.html` - HTML界面
- `web/static/control.js` - JavaScript逻辑
- `scripts/web_control_node.py` - Web节点（已修改）
- `scripts/manual_control_node.py` - 手动控制节点（已创建）

### 配置文件
- `config/manual_control_params.yaml` - 手动控制参数

### 启动文件
- `launch/cleanbot_gazebo.launch.py` - 仿真启动
- `launch/cleanbot.launch.py` - 实机启动

## 测试方法

### 启动系统
```bash
cd ~/桌面/MOON/Electronic/CleanBot_ws
source install/setup.bash

# 仿真
ros2 launch cleanbot_control cleanbot_gazebo.launch.py

# 实机
ros2 launch cleanbot_control cleanbot.launch.py
```

### 访问Web界面
浏览器打开：`http://localhost:8080`

### 测试遥控模式
1. 确保在"手动"导航模式
2. 点击"遥控模式"
3. 拖动虚拟摇杆
4. 观察机器人运动和速度反馈

### 测试里程模式
1. 确保在"手动"导航模式
2. 点击"里程模式"
3. 输入距离和角度
4. 点击"执行运动"
5. 观察机器人精确移动和反馈数据

## 注意事项

1. **导航模式下禁用**：在导航模式下，手动控制自动禁用
2. **建图模式可用**：建图模式下遥控功能可用
3. **红外保护**：红外触发时自动保护，避免碰撞
4. **浏览器缓存**：修改后需强制刷新（Ctrl+F5）
5. **WebSocket连接**：确保WebSocket连接正常

## 版本号

当前版本：`20251226-manual`








